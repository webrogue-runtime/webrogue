use webrogue_events::RawType;

mod code_writer;

#[derive(clap::Parser, Clone)]
struct Cli {
    dec_h_path: std::path::PathBuf,
    dec_c_path: std::path::PathBuf,
}

fn main() -> anyhow::Result<()> {
    let args = <Cli as clap::Parser>::parse();

    let mut dec_h_writer = code_writer::CodeWriter::new();
    let mut dec_c_writer = code_writer::CodeWriter::new();

    let mut writer = &mut dec_h_writer;
    let mut indent = writer.indent_storage();
    macro_rules! w {
        ($($arg:tt)*) => {
            writer.writeln(&format!($($arg)*)).unwrap()
        };
    }
    {
        w!("// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY");
        w!("#ifndef WEBROGUEGFX_h_");
        w!("#define WEBROGUEGFX_h_");
        w!("#include <stddef.h>");
        w!("#include <stdint.h>");
        w!("");
        w!("#ifdef __cplusplus");
        w!("extern \"C\" {{");
        w!("#endif");
        w!("");
        w!("typedef struct wr_window_s wr_window_s;");
        w!("typedef wr_window_s* wr_window;");
        w!("");
        w!("void webroguegfx_make_window(wr_window *out_window);");
        w!("void webroguegfx_window_size(wr_window window, int *width, int *height);");
        w!("void webroguegfx_gl_size(wr_window window, int *width, int *height);");
        w!("uint64_t webroguegfx_vulkan_make_surface(wr_window window, uint64_t vk_instance);");
        w!("");
        w!("// Events");
        for r#enum in webrogue_events::enums() {
            w!("typedef enum {} {{", r#enum.c_name());
            indent.inc(|| {
                for case in r#enum.cases.clone() {
                    w!("{} = {},", case.c_name(&r#enum), case.value);
                }
                w!("");
                w!(
                    "{}_MAX = {},",
                    r#enum.c_name().to_uppercase(),
                    r#enum.ty.c_max()
                );
            });
            w!("}} {};", r#enum.c_name());
            w!("");
        }
        for event in webrogue_events::events() {
            if event.fields.is_empty() {
                continue;
            }
            w!("struct {} {{", event.c_struct_name());
            indent.inc(|| {
                for field in event.fields.clone() {
                    let array_len = match field.ty {
                        webrogue_events::FieldType::Bytes(len) => format!("[{}]", len),
                        _ => "".to_owned(),
                    };
                    w!("{} {}{};", field.ty.c_name(), field.c_name(), array_len);
                }
            });
            w!("}};");
            w!("");
        }
        w!("enum webrogue_event_type {{");
        indent.inc(|| {
            w!("WEBROGUE_EVENT_TYPE_INVALID = 0,");
            for event in webrogue_events::events() {
                w!("{} = {},", event.c_case_name(), event.id);
            }
        });
        w!("}};");
        w!("");
        w!("typedef struct webrogue_event {{");
        indent.inc(|| {
            w!("enum webrogue_event_type type;");
            w!("union {{");
            indent.inc(|| {
                for event in webrogue_events::events() {
                    if event.fields.is_empty() {
                        continue;
                    }
                    w!("struct {} {};", event.c_struct_name(), event.c_union_name());
                }
            });
            w!("}} inner;");
        });
        w!("}} webrogue_event;");
        w!("");
        w!("webrogue_event webroguegfx_poll();");
        w!("");
        w!("#ifdef __cplusplus");
        w!("}}");
        w!("#endif");
        w!("");
        w!("#endif // WEBROGUEGFX_h_");
    }

    writer = &mut dec_c_writer;
    indent = writer.indent_storage();
    {
        w!("// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY");
        w!("// clang-format off");
        w!("#include \"webroguegfx.h\"");
        w!("#include <stdlib.h>");
        w!("#include <string.h>");
        w!("");
        w!(
            "#define WEBROGUE_MAX_ENCODED_EVENT_SIZE {}",
            webrogue_events::events()
                .iter()
                .map(|event| event.size)
                .max()
                .unwrap()
        );
        w!("");
        w!("__attribute__((import_name(\"poll\")))");
        w!("__attribute__((import_module(\"webrogue_gfx\")))");
        w!("void imported_webrogue_gfx_poll(uint32_t* out_len);");
        w!("");
        w!("__attribute__((import_name(\"poll_read\")))");
        w!("__attribute__((import_module(\"webrogue_gfx\")))");
        w!("void imported_webrogue_gfx_poll_read(void *buf);");
        w!("");
        w!("#define BUF_SIZE(LEN) if(available < LEN) {{\\");
        indent.inc(|| {
            w!("buffer_consumed = buffer_used_size;\\");
            w!("result.type = WEBROGUE_EVENT_TYPE_INVALID;\\");
            w!("return result;\\");
        });
        w!("}} buffer_consumed += LEN;");
        w!("#define GET(TYPE, OFFSET) *((TYPE*)(current_pointer + OFFSET));");
        w!("");
        w!("webrogue_event webroguegfx_poll() {{");
        indent.inc(|| {
            w!("webrogue_event result;");
            w!("static void* buffer_data = NULL;");
            w!("if(!buffer_data) {{");
            indent.inc(|| {
                w!("buffer_data = malloc(WEBROGUE_MAX_ENCODED_EVENT_SIZE);");
            });
            w!("}}");
            w!("static uint32_t buffer_max_size = WEBROGUE_MAX_ENCODED_EVENT_SIZE;");
            w!("static uint32_t buffer_used_size = 0;");
            w!("static uint32_t buffer_consumed = 0;");
            w!("uint32_t available = buffer_used_size - buffer_consumed;");
            w!("if(available == 0) {{");
            indent.inc(|| {
                w!("uint32_t new_size;");
                w!("imported_webrogue_gfx_poll(&new_size);");
                w!("if(new_size > buffer_max_size) {{");
                indent.inc(|| {
                    w!("free(buffer_data);");
                    w!("buffer_data = malloc(new_size);");
                    w!("buffer_max_size = new_size;");
                });
                w!("}}");
                w!("if(new_size) {{");
                indent.inc(|| {
                    w!("imported_webrogue_gfx_poll_read(buffer_data);");
                });
                w!("}}");
                w!("buffer_used_size = new_size;");
                w!("buffer_consumed = 0;");
                w!("available = new_size;");
            });
            w!("}}");
            w!("if(available < 4) {{");
            indent.inc(|| {
                w!("buffer_consumed = buffer_used_size;");
                w!("result.type = WEBROGUE_EVENT_TYPE_INVALID;");
                w!("return result;");
            });
            w!("}}");
            w!("const char* current_pointer = ((const char*)buffer_data) + buffer_consumed;");
            w!("result.type = GET(uint32_t, 0);");
            w!("switch (result.type) {{");
            indent.inc(|| {
                for event in webrogue_events::events() {
                    w!("case {}: {{", event.c_case_name());
                    indent.inc(|| {
                        w!("BUF_SIZE({});", event.size);
                        for field in event.fields.clone() {
                            let field_c_name = field.c_name();
                            let mut raw_read = |raw_type: RawType| {
                                w!(
                                    "result.inner.{}.{} = GET({}, {});",
                                    event.c_union_name(),
                                    field_c_name,
                                    raw_type.c_name(),
                                    field.offset
                                );
                            };
                            match field.ty {
                                webrogue_events::FieldType::Enum(r#enum) => raw_read(r#enum.ty),
                                webrogue_events::FieldType::Raw(raw_type) => raw_read(raw_type),
                                webrogue_events::FieldType::Bytes(len) => {
                                    w!(
                                        "memcpy(&result.inner.{}.{}, current_pointer + {}, {});",
                                        event.c_union_name(),
                                        field.c_name(),
                                        field.offset,
                                        len,
                                    )
                                }
                            };
                        }
                        w!("return result;");
                    });
                    w!("}}");
                }
            });

            indent.inc(|| {
                w!("default: {{");
                indent.inc(|| {
                    w!("buffer_consumed = buffer_used_size;");
                    w!("result.type = WEBROGUE_EVENT_TYPE_INVALID;");
                    w!("return result;");
                });
                w!("}}");
            });
            w!("}}");
        });
        w!("}}");
    }

    dec_h_writer.write_to_file(&args.dec_h_path)?;
    dec_c_writer.write_to_file(&args.dec_c_path)?;

    Ok(())
}
