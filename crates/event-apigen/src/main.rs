use std::io::{Read, Write};

#[derive(clap::Parser, Clone)]
struct Cli {
    enc_path: std::path::PathBuf,
    dec_h_path: std::path::PathBuf,
    dec_c_path: std::path::PathBuf,
}

struct CodeWriter {
    buf: Vec<u8>,
    indent: usize,
}

impl CodeWriter {
    pub fn new() -> Self {
        CodeWriter {
            buf: Vec::new(),
            indent: 0,
        }
    }

    pub fn inc_indent(&mut self) {
        self.indent += 1;
    }

    pub fn dec_indent(&mut self) {
        self.indent -= 1;
    }

    pub fn writeln(&mut self, s: &str) -> anyhow::Result<()> {
        let new_string = " ".repeat(self.indent * 4) + s + "\n";
        self.buf.write_all(new_string.as_bytes())?;
        anyhow::Ok(())
    }

    pub fn write_to_file(&mut self, path: &std::path::Path) -> anyhow::Result<()> {
        let mut file = std::fs::OpenOptions::new().read(true).open(path)?;
        let mut old_content = Vec::new();
        file.read_to_end(&mut old_content)?;
        if old_content == self.buf {
            return Ok(());
        }
        drop(file);
        let mut file = std::fs::OpenOptions::new()
            .write(true)
            .truncate(true)
            .open(path)?;
        std::io::Write::write_all(&mut file, &self.buf)?;
        Ok(())
    }
}

fn main() -> anyhow::Result<()> {
    let args = <Cli as clap::Parser>::parse();

    let mut enc_writer = CodeWriter::new();
    let mut dec_h_writer = CodeWriter::new();
    let mut dec_c_writer = CodeWriter::new();

    let mut writer = &mut enc_writer;
    macro_rules! write {
        ($($arg:tt)*) => {
            let args = format_args!($($arg)*);
            writer.writeln(args.as_str().unwrap())?;
        };
    }
    {
        write!("#pragma once");
        write!("// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY");
        write!("#include <stdint.h>");
        write!("");
        write!("typedef struct webrogue_event_out_buf {{");
        writer.inc_indent();
        {
            write!("void* buf;");
            write!("uint32_t buf_size;");
            write!("uint32_t used_size;");
        }
        writer.dec_indent();
        write!("}} webrogue_event_out_buf;");
        write!("");
        write!("#define BUF_SIZE(LEN) if(out->buf_size < LEN) {{ out->used_size = 0; return; }} out->used_size = LEN");
        write!("#define SET(TYPE, OFFSET, VALUE) *((TYPE*)(((char*)out->buf) + OFFSET)) = VALUE");
        write!("");
        write!("static inline void webrogue_event_encode_mouse(webrogue_event_out_buf *out, uint32_t x, uint32_t y) {{");
        writer.inc_indent();
        {
            write!("BUF_SIZE(12);");
            write!("SET(uint32_t, 0, 1);");
            write!("SET(uint32_t, 4, x);");
            write!("SET(uint32_t, 8, y);");
        }
        writer.dec_indent();
        write!("}}");
        write!("");
        write!("#undef BUF_SIZE");
        write!("#undef SET");
    }
    writer = &mut dec_h_writer;
    {
        write!("// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY");
        write!("#include <stddef.h>");
        write!("#include <stdint.h>");
        write!("");
        write!("void webrogue_gfx_present();");
        write!("void webrogue_gfx_make_window();");
        write!("void webrogue_gfx_window_size(int *width, int *height);");
        write!("void webrogue_gfx_gl_size(int *width, int *height);");
        write!("void webrogue_gfx_init_gl();");
        write!("void *webrogueGLLoader(const char *procname);");
        write!("");
        write!("// Events");
        write!("struct webrogue_event_mouse {{");
        writer.inc_indent();
        {
            write!("uint32_t x;");
            write!("uint32_t y;");
        }
        writer.dec_indent();
        write!("}};");
        write!("enum webrogue_event_type {{");
        writer.inc_indent();
        {
            write!("webrogue_event_type_invalid = 0,");
            write!("webrogue_event_type_mouse = 1,");
        }
        writer.dec_indent();
        write!("}};");
        write!("typedef struct webrogue_event {{");
        writer.inc_indent();
        {
            write!("enum webrogue_event_type type;");
            write!("union {{");
            writer.inc_indent();
            {
                write!("struct webrogue_event_mouse mouse;");
            }
            writer.dec_indent();
            write!("}} inner;");
        }
        writer.dec_indent();
        write!("}} webrogue_event;");
        write!("");
        write!("webrogue_event webrogue_gfx_poll();");
    }

    writer = &mut dec_c_writer;
    {
        write!("// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY");
        write!("#include \"webrogue_gfx.h\"");
        write!("#include <stdlib.h>");
        write!("");
        write!("__attribute__((import_name(\"poll\")))");
        write!("__attribute__((import_module(\"webrogue-gfx\")))");
        write!("uint32_t imported_webrogue_gfx_poll();");
        write!("");
        write!("__attribute__((import_name(\"poll-read\")))");
        write!("__attribute__((import_module(\"webrogue-gfx\")))");
        write!("void imported_webrogue_gfx_poll_read(void *buf);");
        write!("#define BUF_SIZE(LEN) if(buffer_len < LEN) {{\\");
        writer.inc_indent();
        {
            write!("free(buffer_data);\\");
            write!("result.type = webrogue_event_type_invalid;\\");
            write!("return result;\\");
        }
        writer.dec_indent();
        write!("}}");
        write!("#define RETURN free(buffer_data); return result;");
        write!("#define GET(TYPE, OFFSET) *((TYPE*)(((char*)buffer_data) + OFFSET));");
        write!("");
        write!("webrogue_event webrogue_gfx_poll() {{");
        writer.inc_indent();
        {
            write!("webrogue_event result;");
            write!("uint32_t buffer_len = imported_webrogue_gfx_poll();");
            write!("void* buffer_data = malloc(buffer_len);");
            write!("BUF_SIZE(4);");
            write!("imported_webrogue_gfx_poll_read(buffer_data);");
            write!("result.type = GET(uint32_t, 0);");
            write!("switch (result.type) {{");
            writer.inc_indent();
            {
                write!("case webrogue_event_type_mouse: {{");
                writer.inc_indent();
                {
                    write!("BUF_SIZE(12);");
                    write!("result.inner.mouse.x = GET(uint32_t, 4);");
                    write!("result.inner.mouse.y = GET(uint32_t, 8);");
                    write!("RETURN;");
                }
                writer.dec_indent();
                write!("}}");
            }
            writer.dec_indent();


            writer.inc_indent();
            {
                write!("default: {{");
                writer.inc_indent();
                {
                    write!("result.type = webrogue_event_type_invalid;");
                    write!("RETURN;");
                }
                writer.dec_indent();
                write!("}}");
            }
            writer.dec_indent();
            write!("}}");
        }
        writer.dec_indent();
        write!("}}");
    }
    write!("#undef BUF_SIZE");
    write!("#undef RETURN");
    write!("#undef GET");

    enc_writer.write_to_file(&args.enc_path)?;
    dec_h_writer.write_to_file(&args.dec_h_path)?;
    dec_c_writer.write_to_file(&args.dec_c_path)?;

    anyhow::Ok(())
}
